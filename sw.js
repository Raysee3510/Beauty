/**
 * Service Worker for Anua vs VT Beauty Comparison
 * Êó•Êú¨‰∏Ä„Ç¶„Çß„Éñ„Éá„Ç∂„Ç§„Éä„ÉºÁõ£‰øÆ
 * PWAÂØæÂøú & „Ç™„Éï„É©„Ç§„É≥Ê©üËÉΩ
 */

const CACHE_NAME = 'beauty-comparison-v2.0.0';
const STATIC_CACHE = 'static-v2.0.0';
const DYNAMIC_CACHE = 'dynamic-v2.0.0';
const OFFLINE_PAGE = './offline.html';

// „Ç≠„É£„ÉÉ„Ç∑„É•„Åô„Çã„É™„ÇΩ„Éº„Çπ
const STATIC_ASSETS = [
    './',
    './index.html',
    './manifest.json',
    './assets/css/style.css',
    './assets/js/script.js',
    './assets/images/icon-192.png',
    './assets/images/icon-512.png',
    './assets/images/favicon.ico',
    // Â§ñÈÉ®„É™„ÇΩ„Éº„Çπ
    'https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&display=swap',
    'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css'
];

// ÂãïÁöÑ„Å´„Ç≠„É£„ÉÉ„Ç∑„É•„Åô„Çã„Éë„Çø„Éº„É≥
const CACHE_PATTERNS = [
    /^https:\/\/fonts\.googleapis\.com\//,
    /^https:\/\/fonts\.gstatic\.com\//,
    /^https:\/\/cdnjs\.cloudflare\.com\//
];

// „Ç≠„É£„ÉÉ„Ç∑„É•„Åó„Å™„ÅÑ„Éë„Çø„Éº„É≥
const NO_CACHE_PATTERNS = [
    /^https:\/\/www\.google-analytics\.com\//,
    /^https:\/\/analytics\.google\.com\//,
    /\/api\//,
    /\?.*$/  // „ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø‰ªò„ÅçURL
];

/**
 * Service Worker „Ç§„É≥„Çπ„Éà„Éº„É´
 */
self.addEventListener('install', event => {
    console.log('üîß Service Worker installing...');
    
    event.waitUntil(
        Promise.all([
            // ÈùôÁöÑ„Ç¢„Çª„ÉÉ„Éà„Çí„Ç≠„É£„ÉÉ„Ç∑„É•
            caches.open(STATIC_CACHE).then(cache => {
                console.log('üì¶ Caching static assets');
                return cache.addAll(STATIC_ASSETS);
            }),
            
            // Âç≥Â∫ß„Å´„Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Éà
            self.skipWaiting()
        ])
    );
});

/**
 * Service Worker „Ç¢„ÇØ„ÉÜ„Ç£„Éô„Éº„Éà
 */
self.addEventListener('activate', event => {
    console.log('üöÄ Service Worker activating...');
    
    event.waitUntil(
        Promise.all([
            // Âè§„ÅÑ„Ç≠„É£„ÉÉ„Ç∑„É•„ÇíÂâäÈô§
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames.map(cacheName => {
                        if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
                            console.log('üóëÔ∏è Deleting old cache:', cacheName);
                            return caches.delete(cacheName);
                        }
                    })
                );
            }),
            
            // ÂÖ®„Å¶„ÅÆ„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÇíÂà∂Âæ°
            self.clients.claim()
        ])
    );
});

/**
 * „Éï„Çß„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà - „É°„Ç§„É≥„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•Êà¶Áï•
 */
self.addEventListener('fetch', event => {
    const { request } = event;
    const url = new URL(request.url);
    
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Åó„Å™„ÅÑ„Éë„Çø„Éº„É≥„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
    if (shouldNotCache(request)) {
        return;
    }
    
    // „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥„É™„ÇØ„Ç®„Çπ„ÉàÔºà„Éö„Éº„Ç∏Ôºâ
    if (request.mode === 'navigate') {
        event.respondWith(handleNavigationRequest(request));
        return;
    }
    
    // ÈùôÁöÑ„Ç¢„Çª„ÉÉ„Éà
    if (isStaticAsset(request)) {
        event.respondWith(handleStaticAsset(request));
        return;
    }
    
    // Â§ñÈÉ®„É™„ÇΩ„Éº„Çπ
    if (isExternalResource(request)) {
        event.respondWith(handleExternalResource(request));
        return;
    }
    
    // „Åù„ÅÆ‰ªñ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà
    event.respondWith(handleOtherRequests(request));
});

/**
 * „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÂá¶ÁêÜ
 * Network First with Cache Fallback
 */
async function handleNavigationRequest(request) {
    try {
        // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÇíÊúÄÂàù„Å´Ë©¶Ë°å
        const networkResponse = await fetch(request);
        
        if (networkResponse.ok) {
            // ÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅØ„Ç≠„É£„ÉÉ„Ç∑„É•„Å´‰øùÂ≠ò
            const cache = await caches.open(DYNAMIC_CACHE);
            cache.put(request, networkResponse.clone());
            return networkResponse;
        }
        
        throw new Error('Network response not ok');
    } catch (error) {
        console.log('üåê Network failed, trying cache:', request.url);
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÂèñÂæó„ÇíË©¶Ë°å
        const cachedResponse = await caches.match(request);
        
        if (cachedResponse) {
            return cachedResponse;
        }
        
        // „Ç™„Éï„É©„Ç§„É≥„Éö„Éº„Ç∏„ÇíËøî„Åô
        const offlinePage = await caches.match('./');
        if (offlinePage) {
            return offlinePage;
        }
        
        // ÊúÄÁµÇÁöÑ„Å´„Ç®„É©„Éº„É¨„Çπ„Éù„É≥„Çπ„ÇíËøî„Åô
        return new Response(
            createOfflineHTML(),
            {
                status: 200,
                statusText: 'OK',
                headers: { 'Content-Type': 'text/html' }
            }
        );
    }
}

/**
 * ÈùôÁöÑ„Ç¢„Çª„ÉÉ„Éà„ÅÆÂá¶ÁêÜ
 * Cache First with Network Fallback
 */
async function handleStaticAsset(request) {
    try {
        // „Ç≠„É£„ÉÉ„Ç∑„É•„ÇíÊúÄÂàù„Å´Á¢∫Ë™ç
        const cachedResponse = await caches.match(request);
        
        if (cachedResponse) {
            return cachedResponse;
        }
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Å´„Å™„ÅÑÂ†¥Âêà„ÅØ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Åã„ÇâÂèñÂæó
        const networkResponse = await fetch(request);
        
        if (networkResponse.ok) {
            const cache = await caches.open(STATIC_CACHE);
            cache.put(request, networkResponse.clone());
        }
        
        return networkResponse;
    } catch (error) {
        console.log('üì¶ Static asset failed:', request.url);
        
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁîªÂÉè„ÇÑCSSÔºàÂøÖË¶Å„Å´Âøú„Åò„Å¶Ôºâ
        if (request.destination === 'image') {
            return new Response(
                createFallbackSVG(),
                {
                    headers: { 'Content-Type': 'image/svg+xml' }
                }
            );
        }
        
        throw error;
    }
}

/**
 * Â§ñÈÉ®„É™„ÇΩ„Éº„Çπ„ÅÆÂá¶ÁêÜ
 * Stale While Revalidate
 */
async function handleExternalResource(request) {
    const cache = await caches.open(DYNAMIC_CACHE);
    const cachedResponse = await cache.match(request);
    
    // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Åß„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Åã„ÇâÊõ¥Êñ∞
    const networkPromise = fetch(request).then(response => {
        if (response.ok) {
            cache.put(request, response.clone());
        }
        return response;
    }).catch(() => {
        // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
    });
    
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Åå„ÅÇ„Çå„Å∞„Åô„Åê„Å´Ëøî„Åô
    if (cachedResponse) {
        return cachedResponse;
    }
    
    // „Ç≠„É£„ÉÉ„Ç∑„É•„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÇíÂæÖ„Å§
    return await networkPromise;
}

/**
 * „Åù„ÅÆ‰ªñ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÂá¶ÁêÜ
 * Network First
 */
async function handleOtherRequests(request) {
    try {
        const networkResponse = await fetch(request);
        
        if (networkResponse.ok) {
            const cache = await caches.open(DYNAMIC_CACHE);
            cache.put(request, networkResponse.clone());
        }
        
        return networkResponse;
    } catch (error) {
        const cachedResponse = await caches.match(request);
        
        if (cachedResponse) {
            return cachedResponse;
        }
        
        throw error;
    }
}

/**
 * „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞
 */
function shouldNotCache(request) {
    return NO_CACHE_PATTERNS.some(pattern => pattern.test(request.url));
}

function isStaticAsset(request) {
    return request.destination === 'script' ||
           request.destination === 'style' ||
           request.destination === 'image' ||
           request.destination === 'font' ||
           request.url.includes('/assets/');
}

function isExternalResource(request) {
    return CACHE_PATTERNS.some(pattern => pattern.test(request.url));
}

/**
 * „Ç™„Éï„É©„Ç§„É≥Áî®HTML„ÅÆÁîüÊàê
 */
function createOfflineHTML() {
    return `
    <!DOCTYPE html>
    <html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>„Ç™„Éï„É©„Ç§„É≥ - ÁæéÂÆπÊ∂≤ÊØîËºÉ„Ç¨„Ç§„Éâ</title>
        <style>
            :root {
                --primary-color: #4a90e2;
                --gray-800: #1e293b;
                --white: #ffffff;
                --light-bg: #f8fafc;
            }
            
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                background: linear-gradient(135deg, var(--light-bg) 0%, #e3f2fd 100%);
                min-height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
                color: var(--gray-800);
            }
            
            .offline-container {
                background: var(--white);
                padding: 40px 30px;
                border-radius: 20px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.1);
                text-align: center;
                max-width: 400px;
                width: 100%;
            }
            
            .offline-icon {
                font-size: 4rem;
                color: var(--primary-color);
                margin-bottom: 20px;
            }
            
            .offline-title {
                font-size: 1.5rem;
                font-weight: 700;
                margin-bottom: 15px;
                color: var(--gray-800);
            }
            
            .offline-message {
                font-size: 1rem;
                line-height: 1.6;
                margin-bottom: 25px;
                opacity: 0.8;
            }
            
            .retry-btn {
                background: var(--primary-color);
                color: var(--white);
                border: none;
                padding: 12px 24px;
                border-radius: 25px;
                font-size: 1rem;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
            }
            
            .retry-btn:hover {
                background: #357abd;
                transform: translateY(-2px);
            }
            
            .features-list {
                margin-top: 30px;
                text-align: left;
            }
            
            .features-list h4 {
                margin-bottom: 15px;
                color: var(--gray-800);
            }
            
            .features-list ul {
                list-style: none;
                padding: 0;
            }
            
            .features-list li {
                padding: 5px 0;
                padding-left: 20px;
                position: relative;
                font-size: 0.9rem;
            }
            
            .features-list li::before {
                content: '‚úì';
                position: absolute;
                left: 0;
                color: var(--primary-color);
                font-weight: bold;
            }
        </style>
    </head>
    <body>
        <div class="offline-container">
            <div class="offline-icon">üì±</div>
            <h1 class="offline-title">„Ç™„Éï„É©„Ç§„É≥„É¢„Éº„Éâ</h1>
            <p class="offline-message">
                „Ç§„É≥„Çø„Éº„Éç„ÉÉ„ÉàÊé•Á∂ö„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ<br>
                „Åì„ÅÆ„Éö„Éº„Ç∏„ÅØ„Ç™„Éï„É©„Ç§„É≥„Åß„ÇÇ‰∏ÄÈÉ®Ê©üËÉΩ„Çí„ÅîÂà©Áî®„ÅÑ„Åü„Å†„Åë„Åæ„Åô„ÄÇ
            </p>
            <button class="retry-btn" onclick="window.location.reload()">
                ÂÜçÊé•Á∂ö„ÇíË©¶„Åô
            </button>
            
            <div class="features-list">
                <h4>„Ç™„Éï„É©„Ç§„É≥„ÅßÂà©Áî®ÂèØËÉΩÔºö</h4>
                <ul>
                    <li>Ë£ΩÂìÅÊØîËºÉÊÉÖÂ†±„ÅÆÈñ≤Ë¶ß</li>
                    <li>ÊàêÂàÜË©≥Á¥∞„ÅÆÁ¢∫Ë™ç</li>
                    <li>Êé®Â•®ÁµêÊûú„ÅÆË°®Á§∫</li>
                    <li>‰ΩøÁî®ÊñπÊ≥ï„ÅÆÁ¢∫Ë™ç</li>
                </ul>
            </div>
        </div>
        
        <script>
            // „Ç™„É≥„É©„Ç§„É≥Âæ©Â∏∞ÊôÇ„ÅÆËá™Âãï„É™„É≠„Éº„Éâ
            window.addEventListener('online', function() {
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
            });
            
            // PWAÊ©üËÉΩ„ÅÆÁ¢∫Ë™ç
            if ('serviceWorker' in navigator) {
                console.log('Service Worker available in offline mode');
            }
        </script>
    </body>
    </html>
    `;
}

/**
 * „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®SVGÁîªÂÉè„ÅÆÁîüÊàê
 */
function createFallbackSVG() {
    return `
    <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#4a90e2;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#7b68ee;stop-opacity:1" />
            </linearGradient>
        </defs>
        <rect width="200" height="200" fill="url(#grad)" rx="20"/>
        <text x="100" y="100" font-family="Arial, sans-serif" font-size="16" 
              fill="white" text-anchor="middle" dy=".3em">
            ÁîªÂÉè„ÇíË™≠„ÅøËæº„Åø‰∏≠...
        </text>
        <circle cx="100" cy="130" r="20" fill="none" stroke="white" stroke-width="2">
            <animate attributeName="stroke-dasharray" 
                     values="0 125;31.25 93.75;62.5 62.5;93.75 31.25;125 0" 
                     dur="2s" repeatCount="indefinite"/>
        </circle>
    </svg>
    `;
}

/**
 * „É°„ÉÉ„Çª„Éº„Ç∏„Ç§„Éô„É≥„ÉàÔºà„Ç¢„Éó„É™„Åã„Çâ„ÅÆÈÄö‰ø°Ôºâ
 */
self.addEventListener('message', event => {
    const { type, payload } = event.data;
    
    switch (type) {
        case 'SKIP_WAITING':
            self.skipWaiting();
            break;
            
        case 'GET_VERSION':
            event.ports[0].postMessage({
                version: CACHE_NAME,
                timestamp: new Date().toISOString()
            });
            break;
            
        case 'CLEAR_CACHE':
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames.map(cacheName => caches.delete(cacheName))
                );
            }).then(() => {
                event.ports[0].postMessage({ success: true });
            });
            break;
            
        case 'PREFETCH_URLS':
            if (payload && payload.urls) {
                prefetchUrls(payload.urls);
            }
            break;
    }
});

/**
 * URL„ÅÆ‰∫ãÂâç„Ç≠„É£„ÉÉ„Ç∑„É•
 */
async function prefetchUrls(urls) {
    const cache = await caches.open(DYNAMIC_CACHE);
    
    const prefetchPromises = urls.map(async (url) => {
        try {
            const response = await fetch(url);
            if (response.ok) {
                await cache.put(url, response);
                console.log('‚úÖ Prefetched:', url);
            }
        } catch (error) {
            console.log('‚ùå Prefetch failed:', url);
        }
    });
    
    await Promise.allSettled(prefetchPromises);
}

/**
 * „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂêåÊúüÔºàÂ∞ÜÊù•„ÅÆÊ©üËÉΩÊã°ÂºµÁî®Ôºâ
 */
self.addEventListener('sync', event => {
    if (event.tag === 'background-sync') {
        event.waitUntil(doBackgroundSync());
    }
});

async function doBackgroundSync() {
    console.log('üîÑ Background sync triggered');
    
    // ‰æãÔºöÂàÜÊûê„Éá„Éº„Çø„ÅÆÈÄÅ‰ø°„ÄÅ„Ç≠„É£„ÉÉ„Ç∑„É•„ÅÆÊõ¥Êñ∞„Å™„Å©
    try {
        // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂÆüË°å„Åó„Åü„ÅÑÂá¶ÁêÜ
        await updateCriticalResources();
    } catch (error) {
        console.log('Background sync failed:', error);
    }
}

async function updateCriticalResources() {
    const criticalUrls = [
        './',
        './assets/css/style.css',
        './assets/js/script.js'
    ];
    
    await prefetchUrls(criticalUrls);
}

/**
 * „Éó„ÉÉ„Ç∑„É•ÈÄöÁü•ÔºàÂ∞ÜÊù•„ÅÆÊ©üËÉΩÊã°ÂºµÁî®Ôºâ
 */
self.addEventListener('push', event => {
    if (!event.data) return;
    
    const options = {
        body: event.data.text(),
        icon: './assets/images/icon-192.png',
        badge: './assets/images/badge-72.png',
        vibrate: [100, 50, 100],
        data: {
            dateOfArrival: Date.now(),
            primaryKey: 1
        },
        actions: [
            {
                action: 'explore',
                title: 'Ë©≥Á¥∞„ÇíË¶ã„Çã',
                icon: './assets/images/checkmark.png'
            },
            {
                action: 'close',
                title: 'Èñâ„Åò„Çã',
                icon: './assets/images/xmark.png'
            }
        ]
    };
    
    event.waitUntil(
        self.registration.showNotification('ÁæéÂÆπÊ∂≤ÊØîËºÉ„Ç¨„Ç§„Éâ', options)
    );
});

/**
 * ÈÄöÁü•„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
 */
self.addEventListener('notificationclick', event => {
    event.notification.close();
    
    if (event.action === 'explore') {
        event.waitUntil(
            clients.openWindow('./#comparison')
        );
    }
});

/**
 * „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
 */
self.addEventListener('error', event => {
    console.error('Service Worker error:', event.error);
});

self.addEventListener('unhandledrejection', event => {
    console.error('Service Worker unhandled rejection:', event.reason);
});

/**
 * Service WorkerÊõ¥Êñ∞„ÉÅ„Çß„ÉÉ„ÇØ
 */
self.addEventListener('updatefound', () => {
    console.log('üîÑ Service Worker update found');
});

// „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±ÔºàÈñãÁô∫ÊôÇ„ÅÆ„ÅøÔºâ
console.log('üèÜ Service Worker loaded - Beauty Comparison PWA v2.0.0');
console.log('üì¶ Cache strategy: Network First for navigation, Cache First for assets');
console.log('üåê Offline support: Enabled');
console.log('üì± PWA features: Install prompt, Background sync, Push notifications');
